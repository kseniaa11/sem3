// laba3.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include "C:\Users\urkae\Desktop\лабараторные\cем3\githab\laba3v\Hash-v.h"
#include <cstring>
#include <stdio.h>
#include <iostream>



    int main()
    {
        Hash h;
        int dia = 0;
        int count;
        while ((dia != 1) && (dia != 2))
        {
            std::cout << "Do you want to\n";
            std::cout << "1.Create empty table\n";
            std::cout << "2.Create n random item\n";
            number(dia);
            switch (dia) 
            {
                case 1: 
                    break;
                case 2:
                    std::cout << "Enter count of item:\n";
                    number(count);
                    try {
                        Hash* h1 = new Hash(count);
                        h = *h1;
                    }
                    catch (std::exception& ex) {
                        std::cout << ex.what() << std::endl;
                    }
                    break;
                default:
                    std::cout << "Wrong parameter, repeat\n";
                    dia = -1;
                    break;
            }
        }
        int key;
        
        while (dia != 0)
        {
            std::cout << "Enter the action:\n";
            std::cout << "1. Add item\n";
            std::cout << "2. Find info\n";
            std::cout << "3. Delete item\n";
            std::cout << "4. Print table\n";
            std::cout << "5. Reorganization\n";
            std::cout << "0. Exit\n";
            number(dia);
            switch (dia)
            {
            case 1:
                try {
                    std::cin >> h;
                }
                catch (std::exception& ex) {
                    std::cout << ex.what() << std::endl;
                }
                try {
                    h += h.pre;
                }
                catch (std::exception& ex) {
                    std::cout << ex.what() << std::endl;
                }
                delete[] h.pre.info;
                break;
            case 2:
                std::cout << "Enter the key:\n";
                number(key);
                try {
                    std::cout << "Item#" << key << " Info:" << h[key].info << "\n";
                }
                catch (std::exception& ex) {
                    std::cout << ex.what() << std::endl;
                }
                break;
            case 3:
                std::cout << "Enter the key:\n";
                number(key);
                try {
                    h -= key;
                }
                catch (std::exception& ex) {
                    std::cout << ex.what() << std::endl;
                }
                break;
            case 4:
                try {
                    std::cout << h;
                }
                catch (std::exception& ex) {
                    std::cout << ex.what() << std::endl;
                }
                break;
            case 5:
                try {
                    h.reorg(h);
                }
                catch (std::exception& ex) {
                    std::cout << ex.what() << std::endl;
                }
                std::cout << "\ntyt?\n";
                break;
            case 0:
                break;
            default:
                std::cout << "Wrong parameter, repeat\n";
                dia = -1;
                break;
            }
        }
        std::cout << "///help\n";

        system("pause");
        return 1;
    }

/* Вариант 18

1. Разработать класс "перемешанная таблица" в соответствии со следующим заданием :
    Состояние класса -
    Таблица представляется в виде вектора(массива), состоящего из элементов.
    Элемент таблицы состоит из ключа(тип int), поля занятости(тип int) и информации(тип char[] фиксированной дли - ны).
    Для описания элемента таблицы целесообразно использовать структуру.Память под массив выделяется статически, во время компиляции, 
    и задается массивом фиксированного размера.
    Преобразование ключа в индекс выполняется функцией хеширования.Элементы перемешиваются методом сложения с константой.
Протокол класса
    Определяет  возможности создания и инициализации экземпляров класса и правила их исполь - зования(методы класса).
Предусмотреть следующие возможности :
    • создание экземпляров структуры(элемента таблицы) с инициализацией начальным состоянием по умолчанию;
    • пустой конструктор для инициализации экземпляров и массивов экземпляров класса(таб - лицы) по умолчанию;
    • создание экземпляров класса(таблицы) с инициализацией заданным количеством элементов из массива ключей и информации;
    • ввод значения экземпляра структуры(элемента таблицы) из входного потока(с помощью перегруженного оператора >> );
    • ==вывод таблицы в выходной поток(с помощью перегруженного оператора << );
    • ==поиск элемента таблицы по ключу(с помощью перегруженного оператора());
    • ==добавление элемента в таблицу(с помощью перегруженного оператора += );
    • ==выборка информации из таблицы по заданному ключу(с помощью перегруженного оператора[]);
    • ==удаление элемента из таблицы(с отметкой в поле занятости) по ключу(с помощью пере - груженного оператора -= );
• чистка таблицы от “удаленных элементов” – реорганизация таблицы.
2. Проектирование класса рекомендуется начать с представления состояния класса, 
    учитывающего заданные операции, а затем реализации конструкторов и перегруженного оператора вывода.
    Для отладки и исчерпывающего тестирования других методов разработанного класса реализовать диалоговую программу, 
    которая позволяет вводить параметры, отлаживаемых методов.
    Для обработки ошибочных ситуаций использовать механизм исключительных ситуаций.
3. Повторить разработку класса при условии, что память под строку символов в элементе таблицы и 
    массив структур необходимой длины выделяется динамически, во время выполнения про - граммы(с помощью оператора new; 
    память задается указателем на char в структуре и указателем на структуру в состоянии класса).
Дополнить интерфейс класса следующими возможностями :
    • память под данные поля информации выделять динамически с помощью оператора new;
    • создание экземпляра класса(таблицы) с его инициализацией другим экземпляром класса(копирующий конструктор) для элемента таблицы и таблицы;
    • переопределение экземпляра класса(с помощью перегруженного оператора присваивания) для элемента таблицы и таблицы.
4. Написать прикладную программу, использующую разработанный класс.*/